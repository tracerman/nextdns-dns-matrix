<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>NextDNS DNS Matrix — Benchmark &amp; Recommend</title>
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --bg: #0d1117;
  --surface: #161b22;
  --border: #30363d;
  --text: #e6edf3;
  --text-dim: #8b949e;
  --cyan: #58a6ff;
  --green: #3fb950;
  --yellow: #d29922;
  --red: #f85149;
  --magenta: #bc8cff;
  --blue: #58a6ff;
  --mono: 'SF Mono', 'Cascadia Code', 'Fira Code', 'JetBrains Mono', Consolas, monospace;
}

body {
  background: var(--bg);
  color: var(--text);
  font-family: var(--mono);
  font-size: 14px;
  line-height: 1.6;
  min-height: 100vh;
  padding: 2rem 1rem;
}

.container {
  max-width: fit-content;
  min-width: min(960px, 100%);
  margin: 0 auto;
}

/* Banner */
.banner {
  position: relative;
  border-radius: 6px;
  padding: 2rem 1.5rem;
  text-align: center;
  margin-bottom: 2rem;
  background: radial-gradient(ellipse 90% 70% at 50% 110%, rgba(88,166,255,0.07), transparent) var(--bg);
  overflow: hidden;
}
/* Animated gradient border via mask */
.banner::before {
  content: '';
  position: absolute;
  inset: 0;
  border-radius: 6px;
  padding: 1px;
  background: linear-gradient(90deg, var(--cyan), var(--magenta), var(--green), var(--cyan));
  background-size: 300% 100%;
  animation: bannerFlow 5s linear infinite;
  -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask-composite: xor;
  mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  mask-composite: exclude;
  pointer-events: none;
}
.banner h1, .banner p { position: relative; z-index: 1; }
.banner h1 {
  font-size: 1.4rem;
  background: linear-gradient(90deg, var(--cyan) 0%, #e6edf3 45%, var(--magenta) 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  margin-bottom: 0.35rem;
  letter-spacing: 0.03em;
}
.banner p {
  color: var(--text-dim);
  font-size: 0.85rem;
}
.pulse-dot {
  display: inline-block;
  width: 7px;
  height: 7px;
  background: var(--green);
  border-radius: 50%;
  margin-right: 0.45rem;
  vertical-align: middle;
  position: relative;
  top: -1px;
  animation: pulseDot 2.5s ease-in-out infinite;
}
@keyframes pulseDot {
  0%, 100% { box-shadow: 0 0 0 0 rgba(63,185,80,0.5); }
  50%       { box-shadow: 0 0 0 5px rgba(63,185,80,0); }
}

/* Form */
.form-section {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 1.5rem;
  margin-bottom: 1.5rem;
}
.form-row {
  display: flex;
  gap: 1rem;
  flex-wrap: wrap;
  align-items: end;
}
.form-group {
  display: flex;
  flex-direction: column;
  gap: 0.4rem;
}
.form-group label {
  font-size: 0.8rem;
  color: var(--text-dim);
}
.form-group input, .form-group select {
  background: var(--bg);
  border: 1px solid var(--border);
  color: var(--text);
  font-family: var(--mono);
  font-size: 0.9rem;
  padding: 0.5rem 0.75rem;
  border-radius: 4px;
  outline: none;
}
.form-group input:focus, .form-group select:focus {
  border-color: var(--cyan);
}
.form-group input::placeholder {
  color: var(--text-dim);
}

.btn {
  background: var(--cyan);
  color: var(--bg);
  border: none;
  font-family: var(--mono);
  font-size: 0.9rem;
  font-weight: 600;
  padding: 0.55rem 1.5rem;
  border-radius: 4px;
  cursor: pointer;
  white-space: nowrap;
}
.btn:hover { opacity: 0.9; }
.btn:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

/* Progress */
.progress-section {
  margin-bottom: 1.5rem;
  display: none;
}
.progress-status {
  color: var(--text-dim);
  font-size: 0.85rem;
  margin-bottom: 0.5rem;
}
.progress-bar-track {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 4px;
  height: 24px;
  overflow: hidden;
}
.progress-bar-fill {
  background: var(--cyan);
  height: 100%;
  width: 0%;
  transition: width 0.2s;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 0.75rem;
  color: var(--bg);
  font-weight: 600;
  min-width: 3rem;
}

/* Results */
.results-section {
  display: none;
}
.section-header {
  font-size: 1rem;
  font-weight: 700;
  margin-bottom: 0.5rem;
  padding-bottom: 0.5rem;
  border-bottom: 1px solid var(--border);
  position: relative;
  padding-left: 0.75rem;
}
.section-header::before {
  content: '';
  position: absolute;
  left: 0;
  top: 0.15em;
  bottom: 0.3em;
  width: 3px;
  background: var(--cyan);
  border-radius: 2px;
}
.sub-header {
  font-size: 0.9rem;
  font-weight: 600;
  margin: 1.25rem 0 0.5rem;
  color: var(--yellow);
}
.insight-box {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 1rem 1.25rem;
  margin-bottom: 1.5rem;
}
.insight-box .stat {
  color: var(--green);
  font-weight: 700;
  font-size: 1rem;
}
.insight-stats {
  display: flex;
  gap: 0.4rem;
  flex-wrap: wrap;
  align-items: center;
  margin-bottom: 0.5rem;
}
.insight-pill {
  display: inline-flex;
  align-items: center;
  padding: 0.12rem 0.55rem;
  border-radius: 20px;
  font-size: 0.75rem;
  font-weight: 600;
  background: rgba(139,148,158,0.1);
  border: 1px solid rgba(139,148,158,0.2);
  color: var(--text-dim);
}
.insight-pill.ok  { background: rgba(63,185,80,0.1);  border-color: rgba(63,185,80,0.25);  color: var(--green); }
.insight-pill.err { background: rgba(248,81,73,0.1);  border-color: rgba(248,81,73,0.25);  color: var(--red);   }
.insight-main { font-size: 0.92rem; margin-bottom: 0.2rem; }
.insight-note { font-size: 0.8rem; color: var(--text-dim); }
.server-badge {
  display: inline-flex;
  align-items: center;
  gap: 0.2rem;
  padding: 0.1rem 0.45rem;
  border-radius: 3px;
  font-size: 0.75rem;
  background: rgba(248,81,73,0.08);
  border: 1px solid rgba(248,81,73,0.18);
  color: var(--red);
  margin: 0.1rem 0.1rem;
}
.spark-bar {
  display: block;
  height: 2px;
  border-radius: 1px;
  margin-top: 3px;
  background: currentColor;
  opacity: 0.4;
}
.cc-badge {
  display: inline-block;
  background: rgba(88,166,255,0.14);
  border: 1px solid rgba(88,166,255,0.35);
  border-radius: 3px;
  padding: 1px 5px;
  font-size: 0.72rem;
  color: var(--cyan);
  letter-spacing: 0.06em;
  font-weight: 700;
  vertical-align: 1px;
  line-height: 1.3;
}

/* Table */
.results-table-wrap {
  margin-bottom: 1.5rem;
  overflow-x: auto;
  -webkit-overflow-scrolling: touch;
}
table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.82rem;
}
th {
  text-align: left;
  color: var(--text-dim);
  font-weight: 400;
  padding: 0.4rem 0.6rem;
  border-bottom: 1px solid var(--border);
  white-space: nowrap;
}
td {
  padding: 0.4rem 0.6rem;
  border-bottom: 1px solid #21262d;
  white-space: nowrap;
}
tr:hover td { background: rgba(88,166,255,0.04); }
.rank-star { color: var(--green); font-weight: 700; }
.type-edge { color: var(--text); }
.type-anycast { color: var(--blue); }
.type-ultralow { color: var(--magenta); }

/* Type legend */
.type-legend {
  display: flex;
  gap: 1.25rem;
  flex-wrap: wrap;
  justify-content: center;
  margin-bottom: 1rem;
  font-size: 0.78rem;
  color: var(--text-dim);
}
.type-legend-item { display: flex; align-items: baseline; gap: 0.35rem; }
.type-legend-dot {
  display: inline-block;
  width: 7px; height: 7px;
  border-radius: 50%;
  flex-shrink: 0;
  position: relative; top: 0.5px;
}
.lat-green { color: var(--green); }
.lat-yellow { color: var(--yellow); }
.lat-red { color: var(--red); }
.text-dim { color: var(--text-dim); }

/* Config section */
.config-section {
  display: none;
  margin-top: 2rem;
}
.config-block {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 0;
  margin-bottom: 1rem;
  overflow: hidden;
}
.card-header {
  padding: 0.6rem 1rem;
  background: rgba(255,255,255,0.025);
  border-bottom: 1px solid var(--border);
}
.card-header h3 {
  font-size: 0.9rem;
  font-weight: 700;
  margin: 0;
}
.card-header .desc {
  color: var(--text-dim);
  font-size: 0.75rem;
  margin-top: 0.2rem;
}
.card-body {
  padding: 0.75rem 1rem;
}
.config-line {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  margin-bottom: 0.35rem;
  flex-wrap: wrap;
}
.config-label {
  color: var(--text-dim);
  min-width: 90px;
  font-size: 0.8rem;
}
.config-value {
  color: var(--cyan);
  font-weight: 600;
  word-break: break-all;
}
.config-value.dim {
  color: var(--text-dim);
  font-weight: 400;
}
.config-note {
  color: var(--text-dim);
  font-size: 0.75rem;
  font-weight: 400;
}
.copy-btn {
  background: transparent;
  border: 1px solid var(--border);
  color: var(--text-dim);
  font-family: var(--mono);
  font-size: 0.7rem;
  padding: 0.15rem 0.5rem;
  border-radius: 3px;
  cursor: pointer;
  white-space: nowrap;
}
.copy-btn:hover { border-color: var(--cyan); color: var(--cyan); }
.copy-btn.copied { border-color: var(--green); color: var(--green); }

/* Error display */
.error-box {
  background: rgba(248,81,73,0.1);
  border: 1px solid var(--red);
  border-radius: 6px;
  padding: 1rem;
  color: var(--red);
  margin-bottom: 1rem;
  display: none;
}


/* ── Animations ─────────────────────────────────────────────────────── */

/* Banner animated border gradient */
@keyframes bannerFlow {
  0%   { background-position: 0% 50%; }
  100% { background-position: 300% 50%; }
}

/* Progress bar moving stripes while benchmark runs */
@keyframes progressStripe {
  to { background-position: -1rem 0; }
}
.progress-bar-fill.running {
  background-image: repeating-linear-gradient(
    -45deg, transparent 0, transparent 6px,
    rgba(0,0,0,0.15) 6px, rgba(0,0,0,0.15) 12px
  );
  background-size: 1rem 1rem;
  animation: progressStripe 0.4s linear infinite;
}

/* Table rows slide in with stagger (delay set per-row via JS) */
@keyframes rowIn {
  from { opacity: 0; transform: translateX(-8px); }
  to   { opacity: 1; transform: translateX(0); }
}
tbody tr {
  opacity: 0;
  animation: rowIn 0.2s ease-out forwards;
}

/* Rank ★ slow glow pulse */
@keyframes starGlow {
  0%, 100% { text-shadow: 0 0 6px rgba(63,185,80,0.5); }
  50%       { text-shadow: 0 0 18px rgba(63,185,80,0.95), 0 0 36px rgba(63,185,80,0.3); }
}
.rank-star { animation: starGlow 2.5s ease-in-out infinite; }

/* Insight box pops in each run */
@keyframes insightPop {
  from { opacity: 0; transform: translateY(6px); }
  to   { opacity: 1; transform: translateY(0); }
}
.insight-box.pop { animation: insightPop 0.3s ease-out; }

/* Card spotlight hover — radial gradient follows cursor (Magic UI style) */
.config-block {
  position: relative;
  overflow: hidden;
}
.config-grid .config-block { margin-bottom: 0; }
.config-block::after {
  content: '';
  position: absolute;
  inset: 0;
  border-radius: inherit;
  background: radial-gradient(
    500px circle at var(--mouse-x, -500px) var(--mouse-y, -500px),
    rgba(88, 166, 255, 0.07),
    transparent 70%
  );
  pointer-events: none;
  z-index: 1;
  opacity: 0;
  transition: opacity 0.3s;
}
.config-block:hover::after { opacity: 1; }

/* Gradient border on recommendation cards to distinguish them as "the answer" */
.config-ipv4, .config-ipv6 {
  border: 1px solid transparent;
  background:
    linear-gradient(var(--surface), var(--surface)) padding-box,
    linear-gradient(135deg, rgba(88,166,255,0.5), rgba(188,140,255,0.35), rgba(63,185,80,0.4)) border-box;
}

/* Insight stat: bright glow that settles into normal green */
@keyframes statPulse {
  0%   { color: #fff; text-shadow: 0 0 20px rgba(63,185,80,0.9); }
  60%  { color: #7ee787; text-shadow: 0 0 8px rgba(63,185,80,0.35); }
  100% { color: var(--green); text-shadow: none; }
}
.insight-box.pop .stat { animation: statPulse 0.9s ease-out forwards; }

/* Routing via-badges on absorbed edge rows */
.via-badge {
  display: inline-block;
  font-size: 0.65rem;
  padding: 1px 5px;
  border-radius: 3px;
  margin-left: 0.3rem;
  background: rgba(188,140,255,0.1);
  border: 1px solid rgba(188,140,255,0.25);
  color: var(--magenta);
  vertical-align: middle;
}

/* Current anycast routing line */
.insight-routing {
  margin-top: 0.3rem;
  font-size: 0.82rem;
  color: var(--text-dim);
}
.insight-routing strong { color: var(--cyan); font-weight: 600; }

/* Current-PoP row in result table */
.current-pop-row { background: rgba(88,166,255,0.05); }
.current-marker {
  display: inline-block;
  color: var(--cyan);
  font-size: 0.65rem;
  margin-left: 0.3rem;
  vertical-align: middle;
  opacity: 0.85;
}

/* ── Bento config grid ───────────────────────────────────────────────── */
.config-grid {
  display: grid;
  grid-template-columns: repeat(6, 1fr);
  gap: 0.75rem;
}
.asus-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 0.5rem 1rem;
}
.config-ipv4      { grid-column: span 3; }
.config-ipv4.solo { grid-column: span 6; }
.config-ipv6      { grid-column: span 3; }
.config-asus      { grid-column: span 6; }
.config-doh       { grid-column: span 2; }
.config-dot       { grid-column: span 2; }
.config-plain     { grid-column: span 2; }

@media (max-width: 860px) {
  .config-grid { grid-template-columns: 1fr 1fr; gap: 0.6rem; }
  .config-ipv4, .config-ipv4.solo, .config-ipv6,
  .config-asus  { grid-column: span 2; }
  .config-doh, .config-dot  { grid-column: span 1; }
  .config-plain { grid-column: span 2; }
}

/* Footer */
.footer {
  margin-top: 3rem;
  padding: 1.75rem 0 0.75rem;
  border-top: 1px solid var(--border);
  text-align: center;
}
.footer-links {
  display: flex;
  justify-content: center;
  gap: 0.5rem;
  flex-wrap: wrap;
  margin-bottom: 0.85rem;
}
.footer-link {
  display: inline-block;
  padding: 0.25rem 0.8rem;
  background: rgba(88,166,255,0.06);
  border: 1px solid rgba(88,166,255,0.2);
  border-radius: 20px;
  color: var(--cyan);
  font-size: 0.78rem;
  text-decoration: none;
  transition: background 0.15s, border-color 0.15s;
  font-family: var(--mono);
}
.footer-link:hover {
  background: rgba(88,166,255,0.14);
  border-color: rgba(88,166,255,0.5);
}
.footer-note {
  color: var(--text-dim);
  font-size: 0.75rem;
  margin-bottom: 0.5rem;
}
.footer-credit {
  color: rgba(139,148,158,0.4);
  font-size: 0.7rem;
}

/* Responsive */
@media (max-width: 960px) {
  /* Prevent fit-content container from overflowing viewport */
  .container { max-width: 100%; }
}

@media (max-width: 600px) {
  body { padding: 1rem 0.5rem; font-size: 13px; }
  .form-row { flex-direction: column; }
  .form-group { width: 100%; }
  .btn { width: 100%; }
  table { font-size: 0.75rem; }
  td, th { padding: 0.3rem 0.4rem; }
  /* Hide Hostname (col 5) and Jitter (col 9) — table scrolls horizontally */
  table th:nth-child(5), table td:nth-child(5) { display: none; }
  table th:nth-child(9), table td:nth-child(9) { display: none; }
  /* Config grid collapses to single column */
  .config-grid { grid-template-columns: 1fr; }
  .asus-grid { grid-template-columns: 1fr; }
  .config-ipv4, .config-ipv4.solo, .config-ipv6,
  .config-asus, .config-doh, .config-dot, .config-plain { grid-column: span 1; }
  /* Config lines stack */
  .config-label { min-width: 70px; }
}
</style>
</head>
<body>

<div class="container">
  <div class="banner">
    <h1><span class="pulse-dot"></span>NextDNS DNS Matrix</h1>
    <p>Benchmark NextDNS servers and find the lowest-latency DNS server for your network</p>
  </div>

  <div class="form-section">
    <div class="form-row">
      <div class="form-group" style="flex:1;min-width:140px">
        <label for="configId">NextDNS Config ID &mdash; <a href="https://my.nextdns.io" target="_blank" rel="noopener" style="color:var(--text-dim);font-size:0.75rem">my.nextdns.io</a></label>
        <input type="text" id="configId" placeholder="e.g. abc123" spellcheck="false" autocomplete="off">
      </div>
      <div class="form-group">
        <label for="rounds">Rounds</label>
        <select id="rounds">
          <option value="1">1</option>
          <option value="3" selected>3</option>
          <option value="5">5</option>
          <option value="10">10</option>
        </select>
      </div>
      <div class="form-group">
        <label for="dohResolver">DNS Resolver</label>
        <select id="dohResolver">
          <option value="google">Google</option>
          <option value="cloudflare">Cloudflare</option>
        </select>
      </div>
      <div class="form-group">
        <label for="preference">Preference</label>
        <select id="preference">
          <option value="auto">auto (lowest latency)</option>
          <option value="ultralow">ultralow</option>
          <option value="anycast">anycast</option>
        </select>
      </div>
      <div class="form-group">
        <label>&nbsp;</label>
        <button class="btn" id="runBtn" onclick="runBenchmark()">Run Benchmark</button>
      </div>
    </div>
  </div>

  <div class="error-box" id="errorBox"></div>

  <div class="progress-section" id="progressSection">
    <div class="progress-status" id="progressStatus">Discovering servers...</div>
    <div class="progress-bar-track">
      <div class="progress-bar-fill" id="progressFill">0%</div>
    </div>
  </div>

  <div class="results-section" id="resultsSection">
    <div class="section-header">Benchmark Results</div>

    <div class="insight-box" id="insightBox"></div>

    <div class="type-legend">
      <span class="type-legend-item">
        <span class="type-legend-dot" style="background:var(--text)"></span>
        <span><span class="type-edge">edge</span> &mdash; individual PoP servers, directly addressed, IPs rotate</span>
      </span>
      <span class="type-legend-item">
        <span class="type-legend-dot" style="background:var(--magenta)"></span>
        <span><span class="type-ultralow">ultralow</span> &mdash; DNS-steered to best PoP, requires DoH/DoT/DoQ</span>
      </span>
      <span class="type-legend-item">
        <span class="type-legend-dot" style="background:var(--blue)"></span>
        <span><span class="type-anycast">anycast</span> &mdash; BGP-routed global IPs, any protocol, automatic failover</span>
      </span>
    </div>

    <div id="ipv4Section">
      <div class="sub-header" id="ipv4Header">IPv4 Servers</div>
      <div class="results-table-wrap">
        <table id="ipv4Table"><thead></thead><tbody></tbody></table>
      </div>
    </div>

    <div id="ipv6Section" style="display:none">
      <div class="sub-header" id="ipv6Header">IPv6 Servers</div>
      <div class="results-table-wrap">
        <table id="ipv6Table"><thead></thead><tbody></tbody></table>
      </div>
    </div>

    <div id="errorServersSection" style="display:none">
      <div class="sub-header" style="color:var(--red)">Unreachable Servers</div>
      <div class="text-dim" id="errorServersList" style="font-size:0.82rem"></div>
    </div>
  </div>

  <div class="config-section" id="configSection">
    <div class="section-header">Recommended Configuration</div>

    <div class="config-grid">
      <div class="config-block config-ipv4" id="configBlockIpv4">
        <div class="card-header"><h3>IPv4 Recommendation</h3></div>
        <div class="card-body" id="ipv4RecConfig"></div>
      </div>

      <div class="config-block config-ipv6" id="ipv6RecBlock" style="display:none">
        <div class="card-header"><h3>IPv6 Recommendation</h3></div>
        <div class="card-body" id="ipv6RecConfig"></div>
      </div>

      <div class="config-block config-asus">
        <div class="card-header">
          <h3>Asus Router (DoT)</h3>
          <div class="desc">WAN &rarr; DNS &rarr; DNS Privacy Protocol &rarr; DNS-over-TLS &rarr; add each server (IP + Hostname, leave port blank)</div>
        </div>
        <div class="card-body" id="asusConfig"></div>
      </div>

      <div class="config-block config-doh">
        <div class="card-header">
          <h3>DNS-over-HTTPS (DoH)</h3>
          <div class="desc">Use this URL in any DoH-compatible client or browser</div>
        </div>
        <div class="card-body" id="dohConfig"></div>
      </div>

      <div class="config-block config-dot">
        <div class="card-header">
          <h3>DNS-over-TLS (DoT)</h3>
          <div class="desc">DNS steering resolves the hostname to your nearest PoP</div>
        </div>
        <div class="card-body" id="dotConfig"></div>
      </div>

      <div class="config-block config-plain">
        <div class="card-header">
          <h3>Plain DNS IPs</h3>
          <div class="desc">Unencrypted fallback &mdash; for routers or IoT devices without DoH/DoT support</div>
        </div>
        <div class="card-body" id="plainConfig"></div>
      </div>
    </div>
  </div>

  <div class="footer">
    <div class="footer-links">
      <a href="https://nextdns.io/" target="_blank" rel="noopener" class="footer-link">NextDNS</a>
      <a href="https://github.com/yokoffing/NextDNS-Config" target="_blank" rel="noopener" class="footer-link">yokoffing/NextDNS-Config</a>
      <a href="https://github.com/tracerman/nextdns-dns-matrix" target="_blank" rel="noopener" class="footer-link">NextDNS DNS Matrix</a>
    </div>
    <div class="footer-note">All node IPs rotate &mdash; always run fresh before using results.</div>
    <div class="footer-credit">Made with Love, Blood, and Coffee</div>
  </div>
</div>

<script>
// ─── Constants ────────────────────────────────────────────────────────────────

const PING_TIMEOUT = 3000;
const MAX_CONCURRENT = 6;
const STAGGER_MS = 80;

const ANYCAST_HOSTNAMES = [
  { hostname: 'ipv4-anycast.dns1.nextdns.io', family: 'IPv4', dnsNum: 1 },
  { hostname: 'ipv4-anycast.dns2.nextdns.io', family: 'IPv4', dnsNum: 2 },
  { hostname: 'ipv6-anycast.dns1.nextdns.io', family: 'IPv6', dnsNum: 1 },
  { hostname: 'ipv6-anycast.dns2.nextdns.io', family: 'IPv6', dnsNum: 2 },
];

const ULTRALOW_HOSTNAMES = [
  { hostname: 'ipv4.dns1.nextdns.io', family: 'IPv4', dnsNum: 1 },
  { hostname: 'ipv4.dns2.nextdns.io', family: 'IPv4', dnsNum: 2 },
  { hostname: 'ipv6.dns1.nextdns.io', family: 'IPv6', dnsNum: 1 },
  { hostname: 'ipv6.dns2.nextdns.io', family: 'IPv6', dnsNum: 2 },
];

const ANYCAST_FALLBACK = {
  ipv4: { dns1: '45.90.28.0', dns2: '45.90.30.0' },
  ipv6: { dns1: '2a07:a8c0::', dns2: '2a07:a8c1::' },
};

// ─── Utilities ────────────────────────────────────────────────────────────────

function sleep(ms) {
  return new Promise(r => setTimeout(r, ms));
}

function showError(msg) {
  const box = document.getElementById('errorBox');
  box.textContent = msg;
  box.style.display = 'block';
}

function hideError() {
  document.getElementById('errorBox').style.display = 'none';
}


function setProgress(status, pct) {
  document.getElementById('progressStatus').textContent = status;
  const fill = document.getElementById('progressFill');
  fill.style.width = pct + '%';
  fill.textContent = pct + '%';
}

function latencyClass(ms) {
  if (ms < 20) return 'lat-green';
  if (ms < 40) return 'lat-yellow';
  return 'lat-red';
}

function typeClass(type) {
  if (type === 'server') return 'type-edge';
  return 'type-' + type;
}

function escHtml(s) {
  const d = document.createElement('div');
  d.textContent = s;
  return d.innerHTML;
}

function parseLocation(loc) {
  if (!loc) return { flag: '', city: '' };
  const s = loc.trim();
  let flag = '';
  let rest = s;
  // Format from /info API: "us Ashburn, United States" — 2-char ISO prefix + space
  if (/^[a-z]{2}\s/i.test(s)) {
    flag = s.slice(0, 2).toUpperCase();
    rest = s.slice(3).trim();
  }
  // Strip country — split on first comma (allowing optional leading whitespace)
  const parts = rest.split(/\s*,/);
  const city = (parts[0] || rest).trim();
  return { flag, city };
}

async function copyToClipboard(text, btn) {
  try {
    await navigator.clipboard.writeText(text);
    btn.textContent = 'copied';
    btn.classList.add('copied');
    setTimeout(() => { btn.textContent = 'copy'; btn.classList.remove('copied'); }, 1500);
  } catch { /* ignore */ }
}

// ─── Server Discovery ─────────────────────────────────────────────────────────

async function discoverServers(onStatus) {
  const servers = [];

  // 1. Fetch geo-tailored PoP servers from router API
  // Response: [{ pop: "hetzner-iad", server: "hetzner-iad-1", ipv4: true, ipv6: true }, ...]
  onStatus('Fetching server list from router.nextdns.io...');
  try {
    const resp = await fetch('https://router.nextdns.io/?source=ping');
    if (resp.ok) {
      const data = await resp.json();
      if (Array.isArray(data)) {
        for (const entry of data) {
          const srv = entry.server || '';
          const pop = entry.pop || srv;
          if (!srv) continue;
          // IPv4
          if (entry.ipv4 !== false) {
            servers.push({
              hostname: `ipv4-${srv}.edge.nextdns.io`,
              type: 'server',
              family: 'IPv4',
              nodeId: pop,
            });
          }
          // IPv6
          if (entry.ipv6) {
            servers.push({
              hostname: `ipv6-${srv}.edge.nextdns.io`,
              type: 'server',
              family: 'IPv6',
              nodeId: pop,
            });
          }
        }
      }
    }
  } catch (e) {
    console.warn('router.nextdns.io fetch failed:', e);
  }

  // 2. Add anycast hostnames
  for (const ac of ANYCAST_HOSTNAMES) {
    servers.push({
      hostname: ac.hostname,
      type: 'anycast',
      family: ac.family,
      nodeId: ac.dnsNum === 1 ? 'anycast1' : 'anycast2',
    });
  }

  // 3. Add ultralow hostnames
  for (const ul of ULTRALOW_HOSTNAMES) {
    servers.push({
      hostname: ul.hostname,
      type: 'ultralow',
      family: ul.family,
      nodeId: ul.dnsNum === 1 ? 'ultralow1' : 'ultralow2',
    });
  }

  onStatus(`Discovered ${servers.length} server endpoints`);
  return servers;
}

// ─── Benchmark Single Server ──────────────────────────────────────────────────

async function benchmarkServer(server, rounds) {
  const results = [];

  for (let i = 0; i < rounds; i++) {
    try {
      const controller = new AbortController();
      const timer = setTimeout(() => controller.abort(), PING_TIMEOUT);

      const t0 = performance.now();
      const resp = await fetch(`https://${server.hostname}/info`, {
        signal: controller.signal,
        cache: 'no-store',
      });
      const t1 = performance.now();
      clearTimeout(timer);

      if (resp.ok) {
        const data = await resp.json();
        results.push({
          clientMs: Math.round((t1 - t0) * 100) / 100,
          serverRttUs: data.rtt || null,
          pop: data.pop || null,
          location: data.locationName || null,
        });
      }
    } catch {
      // timeout or network error — skip this round
    }

    if (i < rounds - 1) await sleep(STAGGER_MS);
  }

  if (results.length === 0) {
    return {
      ...server,
      avgMs: Infinity,
      minMs: Infinity,
      maxMs: Infinity,
      jitter: Infinity,
      successRate: 0,
      status: 'error',
      pop: null,
      location: null,
    };
  }

  // Use server-reported RTT (microseconds → ms) as primary metric
  const hasServerRtt = results[0].serverRttUs !== null;
  const times = hasServerRtt
    ? results.map(r => r.serverRttUs / 1000)
    : results.map(r => r.clientMs);

  const avg = times.reduce((a, b) => a + b, 0) / times.length;
  const min = Math.min(...times);
  const max = Math.max(...times);

  return {
    ...server,
    avgMs: Math.round(avg * 100) / 100,
    minMs: Math.round(min * 100) / 100,
    maxMs: Math.round(max * 100) / 100,
    jitter: Math.round((max - min) * 100) / 100,
    successRate: Math.round((results.length / rounds) * 100),
    status: 'ok',
    pop: results[0].pop,
    location: results[0].location,
  };
}

// ─── Full Benchmark ───────────────────────────────────────────────────────────

async function runFullBenchmark(servers, rounds, onProgress) {
  const results = [];
  let completed = 0;

  for (let i = 0; i < servers.length; i += MAX_CONCURRENT) {
    const batch = servers.slice(i, i + MAX_CONCURRENT);
    const batchResults = await Promise.all(batch.map(s => benchmarkServer(s, rounds)));
    results.push(...batchResults);
    completed += batch.length;
    onProgress(completed, servers.length);
  }

  return results;
}

// ─── Ranking ──────────────────────────────────────────────────────────────────

function rankResults(results, preference, toleranceMs = 10) {
  const sorted = [...results];
  sorted.sort((a, b) => {
    if (a.status !== b.status) return a.status === 'ok' ? -1 : 1;
    if (preference === 'auto') return a.avgMs - b.avgMs;

    const diff = a.avgMs - b.avgMs;
    const aP = a.type === preference;
    const bP = b.type === preference;
    if (aP && !bP && diff < toleranceMs) return -1;
    if (!aP && bP && -diff < toleranceMs) return 1;
    return a.avgMs - b.avgMs;
  });
  return sorted;
}

// ─── IP Resolution via DoH ────────────────────────────────────────────────────

const DOH_RESOLVERS = {
  google:     { label: 'Google',     url: 'https://dns.google/resolve',             batch: 8, delayMs: 0 },
  cloudflare: { label: 'Cloudflare', url: 'https://cloudflare-dns.com/dns-query',   batch: 4, delayMs: 150, headers: { 'Accept': 'application/dns-json' } },
};

async function resolveHostname(hostname, type = 'A', resolver = 'google') {
  const cfg = DOH_RESOLVERS[resolver] || DOH_RESOLVERS.google;
  const maxRetries = 2;
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      const resp = await fetch(`${cfg.url}?name=${encodeURIComponent(hostname)}&type=${type}`, {
        headers: cfg.headers || {},
      });
      if (resp.status === 429) {
        await sleep(500 * (attempt + 1));
        continue;
      }
      if (!resp.ok) return null;
      const data = await resp.json();
      if (data.Answer && data.Answer.length > 0) {
        const record = data.Answer.find(a => a.type === (type === 'A' ? 1 : 28));
        return record ? record.data : null;
      }
      return null;
    } catch {
      if (attempt < maxRetries - 1) await sleep(300 * (attempt + 1));
    }
  }
  return null;
}

// ─── Bulk IP Resolution ───────────────────────────────────────────────────────

async function resolveAllIPs(results, onProgress, resolver = 'google') {
  const ok = results.filter(r => r.status === 'ok');
  const hostnames = new Map(); // hostname -> { qtype, indices[] }

  // Group results by unique hostname+qtype
  ok.forEach((r, idx) => {
    const qtype = r.family === 'IPv6' ? 'AAAA' : 'A';
    const key = r.hostname + '|' + qtype;
    if (!hostnames.has(key)) {
      hostnames.set(key, { hostname: r.hostname, qtype, indices: [] });
    }
    hostnames.get(key).indices.push(idx);
  });

  const jobs = [...hostnames.values()];
  let completed = 0;
  const cfg = DOH_RESOLVERS[resolver] || DOH_RESOLVERS.google;
  const batchSize = cfg.batch || 8;
  const delayMs = cfg.delayMs || 0;

  for (let i = 0; i < jobs.length; i += batchSize) {
    if (i > 0 && delayMs > 0) await sleep(delayMs);
    const batch = jobs.slice(i, i + batchSize);
    const batchResults = await Promise.all(
      batch.map(j => resolveHostname(j.hostname, j.qtype, resolver))
    );
    batch.forEach((j, bi) => {
      const ip = batchResults[bi];
      if (ip) {
        for (const idx of j.indices) {
          ok[idx].resolvedIP = ip;
        }
      }
    });
    completed += batch.length;
    onProgress(completed, jobs.length);
  }
}

// ─── Config Generation ────────────────────────────────────────────────────────

function generateConfig(ranked, configId) {
  const ok = ranked.filter(r => r.status === 'ok');
  const ipv4 = ok.filter(r => r.family === 'IPv4');
  const ipv6 = ok.filter(r => r.family === 'IPv6');

  const bestV4 = ipv4[0] || null;
  const secondV4 = ipv4[1] || null;
  const bestV6 = ipv6[0] || null;
  const secondV6 = ipv6[1] || null;

  const anycastV4 = ipv4.filter(r => r.type === 'anycast');
  const anycastV6 = ipv6.filter(r => r.type === 'anycast');

  // Use already-resolved IPs from the bulk resolution phase
  const primaryIP = (bestV4 && bestV4.resolvedIP) || ANYCAST_FALLBACK.ipv4.dns1;
  const secondaryIP = (secondV4 && secondV4.resolvedIP) || ANYCAST_FALLBACK.ipv4.dns2;

  const anycastIP1 = (anycastV4[0] && anycastV4[0].resolvedIP) || ANYCAST_FALLBACK.ipv4.dns1;
  const anycastIP2 = (anycastV4[1] && anycastV4[1].resolvedIP) || ANYCAST_FALLBACK.ipv4.dns2;

  const bestV6IP = (bestV6 && bestV6.resolvedIP) || ANYCAST_FALLBACK.ipv6.dns1;
  const secondV6IP = (secondV6 && secondV6.resolvedIP) || ANYCAST_FALLBACK.ipv6.dns2;
  const anycastV6IP1 = (anycastV6[0] && anycastV6[0].resolvedIP) || ANYCAST_FALLBACK.ipv6.dns1;
  const anycastV6IP2 = (anycastV6[1] && anycastV6[1].resolvedIP) || ANYCAST_FALLBACK.ipv6.dns2;

  const dotHostname = `${configId}.dns.nextdns.io`;

  return {
    ipv4: {
      best:     { ip: primaryIP,   hostname: dotHostname, result: bestV4 },
      backup:   { ip: secondaryIP, hostname: dotHostname, result: secondV4 },
      anycast1: { ip: anycastIP1,  hostname: dotHostname },
      anycast2: { ip: anycastIP2,  hostname: dotHostname },
    },
    ipv6: {
      best:     { ip: bestV6IP,      hostname: dotHostname, result: bestV6 },
      backup:   { ip: secondV6IP,    hostname: dotHostname, result: secondV6 },
      anycast1: { ip: anycastV6IP1,  hostname: dotHostname },
      anycast2: { ip: anycastV6IP2,  hostname: dotHostname },
    },
    doh: `https://dns.nextdns.io/${configId}`,
    dot: dotHostname,
    bestV4, secondV4, bestV6, secondV6,
    anycastV4Best: anycastV4[0] || null,
    improvementMs: (bestV4 && anycastV4[0] && bestV4.type !== 'anycast')
      ? Math.round((anycastV4[0].avgMs - bestV4.avgMs) * 100) / 100
      : null,
  };
}

// ─── Render Results ───────────────────────────────────────────────────────────

function serverLabel(r) {
  return r.nodeId || r.hostname;
}

function renderTable(tableId, servers, currentPop = null) {
  const table = document.getElementById(tableId);
  const thead = table.querySelector('thead');
  const tbody = table.querySelector('tbody');

  thead.innerHTML = `<tr>
    <th>#</th><th>Node ID</th><th>Location</th><th>Type</th>
    <th>Hostname</th><th>IP</th>
    <th>Avg</th><th>Min</th><th>Jitter</th><th>OK%</th>
  </tr>`;

  // Build map: edge nodeId → routing labels that resolve to it
  const routingTo = {};
  for (const r of servers) {
    if (r.resolvedToEdge) {
      if (!routingTo[r.resolvedToEdge]) routingTo[r.resolvedToEdge] = [];
      routingTo[r.resolvedToEdge].push(serverLabel(r));
    }
  }

  // Remove anycast/ultralow rows that are absorbed by an edge row
  const displayed = servers.filter(r => !r.resolvedToEdge);

  tbody.innerHTML = '';
  const maxMs = displayed.length > 0 ? Math.max(...displayed.map(s => s.avgMs)) : 1;
  displayed.forEach((r, i) => {
    const isCurrent = currentPop && (r.nodeId === currentPop || r.pop === currentPop);
    const rank = i === 0
      ? '<span class="rank-star">&#9733;</span>'
      : `<span class="text-dim">${i + 1}</span>`;
    const currentMarker = isCurrent
      ? '<span class="current-marker" title="Anycast currently routes here">&#9658;</span>'
      : '';

    const viaLabels = routingTo[r.nodeId] || [];
    const viaBadges = viaLabels.map(v => `<span class="via-badge">${escHtml(v)}</span>`).join('');

    const { flag, city } = parseLocation(r.location || r.pop || '');
    const locCell = flag
      ? `<span class="cc-badge">${escHtml(flag)}</span> ${escHtml(city)}`
      : escHtml(city || r.pop || '');
    const ip = r.resolvedIP || '';
    const typeLabel = r.type === 'server' ? 'edge' : r.type;
    const barWidth = maxMs > 0 ? Math.max(4, Math.round((r.avgMs / maxMs) * 60)) : 4;
    const tr = document.createElement('tr');
    if (isCurrent) tr.classList.add('current-pop-row');
    tr.innerHTML = `
      <td>${rank}${currentMarker}</td>
      <td>${escHtml(serverLabel(r))}${viaBadges}</td>
      <td class="text-dim">${locCell}</td>
      <td class="${typeClass(r.type)}">${typeLabel}</td>
      <td class="text-dim" style="font-size:0.75rem">${escHtml(r.hostname)}</td>
      <td>${ip ? escHtml(ip) : '<span class="text-dim">-</span>'}</td>
      <td class="${latencyClass(r.avgMs)}"><span>${r.avgMs}ms</span><span class="spark-bar" style="width:${barWidth}px"></span></td>
      <td class="text-dim">${r.minMs}ms</td>
      <td class="text-dim">${r.jitter}ms</td>
      <td>${r.successRate === 100 ? '<span class="lat-green">100%</span>' : '<span class="lat-yellow">' + r.successRate + '%</span>'}</td>
    `;
    tr.style.animationDelay = (i * 25) + 'ms';
    tbody.appendChild(tr);
  });
}

function resultNote(result) {
  if (!result) return '';
  const label = result.nodeId || result.type;
  return `(${result.avgMs}ms ${label})`;
}

function renderRecSection(entry, label) {
  const r = entry.result;
  const nodeLabel = r ? (r.nodeId || r.type) : '';
  const badge = r
    ? ' <span class="' + latencyClass(r.avgMs) + '">' + r.avgMs + 'ms</span> <span class="text-dim">' + escHtml(nodeLabel) + '</span>'
    : '';
  return `<div style="margin-bottom:0.4rem">
    <div style="color:var(--text-dim);font-size:0.75rem;margin-bottom:0.15rem">${escHtml(label)}${badge}</div>
    ${configLine('IP:', entry.ip)}
    ${configLine('Hostname:', entry.hostname)}
  </div>`;
}

function renderConfig(config, configId) {
  const section = document.getElementById('configSection');
  section.style.display = 'block';

  // IPv4 Recommendation
  let v4Html = renderRecSection(config.ipv4.best, 'Best');
  v4Html += renderRecSection(config.ipv4.backup, 'Backup');
  v4Html += '<hr style="border-color:var(--border);margin:0.35rem 0">';
  v4Html += `<div style="color:var(--text-dim);font-size:0.75rem;margin-bottom:0.15rem">Anycast Fallback</div>`;
  v4Html += configLine('IP 1:', config.ipv4.anycast1.ip, true);
  v4Html += configLine('IP 2:', config.ipv4.anycast2.ip, true);
  document.getElementById('ipv4RecConfig').innerHTML = v4Html;

  // Insight pop re-trigger on each run
  const insightEl = document.getElementById('insightBox');
  insightEl.classList.remove('pop');
  void insightEl.offsetWidth;
  insightEl.classList.add('pop');

  // IPv6 Recommendation
  const ipv4Block = document.getElementById('configBlockIpv4');
  if (config.bestV6) {
    document.getElementById('ipv6RecBlock').style.display = 'block';
    ipv4Block.classList.remove('solo');
    let v6Html = renderRecSection(config.ipv6.best, 'Best');
    v6Html += renderRecSection(config.ipv6.backup, 'Backup');
    v6Html += '<hr style="border-color:var(--border);margin:0.35rem 0">';
    v6Html += `<div style="color:var(--text-dim);font-size:0.75rem;margin-bottom:0.15rem">Anycast Fallback</div>`;
    v6Html += configLine('IP 1:', config.ipv6.anycast1.ip, true);
    v6Html += configLine('IP 2:', config.ipv6.anycast2.ip, true);
    document.getElementById('ipv6RecConfig').innerHTML = v6Html;
  } else {
    ipv4Block.classList.add('solo');
  }

  // Asus DoT — 2-column grid layout
  const asusEntries = [
    { label: 'Primary (IPv4 Best)', entry: config.ipv4.best },
    { label: 'Secondary (IPv4 Backup)', entry: config.ipv4.backup },
  ];
  if (config.bestV6) {
    asusEntries.push({ label: 'Primary IPv6', entry: config.ipv6.best });
    asusEntries.push({ label: 'Secondary IPv6', entry: config.ipv6.backup });
  }
  asusEntries.push({ label: 'Fallback 1 (Anycast)', entry: config.ipv4.anycast1 });
  asusEntries.push({ label: 'Fallback 2 (Anycast)', entry: config.ipv4.anycast2 });

  let asus = '<div class="asus-grid">';
  for (const { label, entry } of asusEntries) {
    asus += `<div>
      <div style="color:var(--text-dim);font-size:0.75rem;margin-bottom:0.15rem">${escHtml(label)}</div>
      ${configLine('IP:', entry.ip)}
      ${configLine('Hostname:', entry.hostname)}
    </div>`;
  }
  asus += '</div>';
  document.getElementById('asusConfig').innerHTML = asus;

  // DoH
  document.getElementById('dohConfig').innerHTML =
    configLine('URL:', config.doh);

  // DoT
  document.getElementById('dotConfig').innerHTML =
    configLine('Hostname:', config.dot);

  // Plain DNS
  let plain = configLine('IPv4 Best:', config.ipv4.best.ip,
    false, resultNote(config.bestV4));
  plain += configLine('IPv4 Backup:', config.ipv4.backup.ip,
    true, resultNote(config.secondV4));
  plain += configLine('IPv4 Anycast:', config.ipv4.anycast1.ip + ' / ' + config.ipv4.anycast2.ip, true);

  if (config.bestV6) {
    plain += '<hr style="border-color:var(--border);margin:0.5rem 0">';
    plain += configLine('IPv6 Best:', config.ipv6.best.ip);
    plain += configLine('IPv6 Backup:', config.ipv6.backup.ip, true);
    plain += configLine('IPv6 Anycast:', config.ipv6.anycast1.ip + ' / ' + config.ipv6.anycast2.ip, true);
  }
  document.getElementById('plainConfig').innerHTML = plain;
}

function configLine(label, value, dim = false, note = '') {
  const safeValue = value.replace(/&/g,'&amp;').replace(/"/g,'&quot;');
  return `<div class="config-line">
    <span class="config-label">${label}</span>
    <span class="config-value${dim ? ' dim' : ''}">${escHtml(value)}</span>
    ${note ? '<span class="config-note">' + escHtml(note) + '</span>' : ''}
    <button class="copy-btn" data-copy="${safeValue}" onclick="copyToClipboard(this.dataset.copy, this)">copy</button>
  </div>`;
}

// ─── Main Entry ───────────────────────────────────────────────────────────────

async function runBenchmark() {
  const configId = document.getElementById('configId').value.trim();
  const rounds = parseInt(document.getElementById('rounds').value);
  const preference = document.getElementById('preference').value;
  const resolver = document.getElementById('dohResolver').value;

  if (!configId || configId.length < 4) {
    showError('Please enter a valid NextDNS config ID (at least 4 characters). Find it at my.nextdns.io → Setup.');
    return;
  }

  hideError();
  const btn = document.getElementById('runBtn');
  btn.disabled = true;
  btn.textContent = 'Running...';

  const progressSection = document.getElementById('progressSection');
  const resultsSection = document.getElementById('resultsSection');
  const configSection = document.getElementById('configSection');
  progressSection.style.display = 'block';
  resultsSection.style.display = 'none';
  configSection.style.display = 'none';
  document.getElementById('progressFill').classList.add('running');

  try {
    // Phase 1: Discovery
    setProgress('Discovering servers...', 0);
    const servers = await discoverServers(msg => setProgress(msg, 5));

    if (servers.length === 0) {
      showError('No servers discovered. Check your internet connection.');
      return;
    }

    setProgress(`Discovered ${servers.length} servers. Benchmarking...`, 10);

    // Phase 2: Benchmark
    const results = await runFullBenchmark(servers, rounds, (cur, tot) => {
      const pct = Math.round(10 + (cur / tot) * 80);
      setProgress(`Benchmarking: ${cur}/${tot} servers...`, pct);
    });

    // Phase 3: Resolve IPs
    setProgress(`Resolving DNS via ${DOH_RESOLVERS[resolver].label}...`, 90);
    await resolveAllIPs(results, (cur, tot) => {
      const pct = Math.round(90 + (cur / tot) * 5);
      setProgress(`Resolving IPs: ${cur}/${tot} hostnames...`, pct);
    }, resolver);

    // Phase 4: Rank
    setProgress('Ranking results...', 96);
    const ranked = rankResults(results, preference);

    const ok = ranked.filter(r => r.status === 'ok');
    const errors = ranked.filter(r => r.status === 'error');
    const ipv4 = ok.filter(r => r.family === 'IPv4');
    const ipv6 = ok.filter(r => r.family === 'IPv6');

    // Cross-reference: mark anycast/ultralow rows that map to the same edge server
    for (const family of [ipv4, ipv6]) {
      // Build map by IP for ultralow (unicast IPs match edge servers directly)
      const edgeIpMap = {};
      // Build map by pop/nodeId for anycast (BGP IPs differ; link is via .pop field)
      const edgePopMap = {};
      for (const r of family) {
        if (r.type === 'server') {
          if (r.resolvedIP) edgeIpMap[r.resolvedIP] = r.nodeId;
          if (r.nodeId)     edgePopMap[r.nodeId]    = r.nodeId;
          if (r.pop)        edgePopMap[r.pop]        = r.nodeId;
        }
      }
      for (const r of family) {
        if (r.type === 'ultralow' && r.resolvedIP) {
          r.resolvedToEdge = edgeIpMap[r.resolvedIP] || null;
        }
        if (r.type === 'anycast' && r.pop) {
          r.resolvedToEdge = edgePopMap[r.pop] || null;
        }
      }
    }

    // Render results
    resultsSection.style.display = 'block';

    // Insight box
    const insightBox = document.getElementById('insightBox');
    const anycastV4 = ipv4.filter(r => r.type === 'anycast');
    const currentAnycastPop = anycastV4[0] ? anycastV4[0].pop : null;
    let insightHtml = `<div class="insight-stats">
      <span class="insight-pill">${ranked.length} tested</span>
      <span class="insight-pill ok">${ok.length} reachable</span>
      ${errors.length > 0 ? `<span class="insight-pill err">${errors.length} unreachable</span>` : ''}
    </div>`;
    if (ipv4[0] && anycastV4[0] && ipv4[0].type !== 'anycast') {
      const imp = Math.round((anycastV4[0].avgMs - ipv4[0].avgMs) * 100) / 100;
      if (imp > 0) {
        insightHtml += `<div class="insight-main"><span class="stat">${imp}ms lower latency</span> <span class="text-dim">vs anycast</span></div>`;
        insightHtml += `<div class="insight-note">${escHtml(serverLabel(ipv4[0]))} <span class="lat-green">${ipv4[0].avgMs}ms</span> <span class="text-dim">vs anycast</span> <span class="lat-yellow">${anycastV4[0].avgMs}ms</span></div>`;
      } else {
        insightHtml += `<div class="insight-main" style="color:var(--blue)">Anycast is currently optimal &mdash; no change needed.</div>`;
      }
    } else if (ipv4[0]) {
      insightHtml += `<div class="insight-main"><span class="stat">${ipv4[0].avgMs}ms</span> <span class="text-dim">best IPv4 &mdash; ${escHtml(serverLabel(ipv4[0]))}</span></div>`;
    }
    if (currentAnycastPop) {
      const { flag, city } = parseLocation(anycastV4[0].location || '');
      const locStr = city ? (flag ? `[${flag}] ${city}` : city) : currentAnycastPop;
      insightHtml += `<div class="insight-routing">Anycast routes you to: <strong>${escHtml(currentAnycastPop)}</strong> <span class="text-dim">${escHtml(locStr)} &middot; ${anycastV4[0].avgMs}ms</span></div>`;
    }
    if (preference !== 'auto') {
      insightHtml += `<div class="insight-note">Ranking boosted <strong>${preference}</strong> servers within 10ms tolerance</div>`;
    }
    insightBox.innerHTML = insightHtml;

    // IPv4 table
    if (ipv4.length > 0) {
      document.getElementById('ipv4Section').style.display = 'block';
      document.getElementById('ipv4Header').textContent = `IPv4 Servers (${ipv4.length} reachable)`;
      renderTable('ipv4Table', ipv4, currentAnycastPop);
    }

    // IPv6 table
    if (ipv6.length > 0) {
      document.getElementById('ipv6Section').style.display = 'block';
      document.getElementById('ipv6Header').textContent = `IPv6 Servers (${ipv6.length} reachable)`;
      const anycastV6 = ipv6.filter(r => r.type === 'anycast');
      const currentAnycastV6Pop = anycastV6[0] ? anycastV6[0].pop : null;
      renderTable('ipv6Table', ipv6, currentAnycastV6Pop);
    } else {
      document.getElementById('ipv6Section').style.display = 'none';
    }

    // Error servers
    if (errors.length > 0) {
      document.getElementById('errorServersSection').style.display = 'block';
      const shown = errors.slice(0, 15);
      const badges = shown.map(r =>
        `<span class="server-badge">${escHtml(serverLabel(r))} <span style="opacity:0.55">${r.family}</span></span>`
      ).join('');
      const extra = errors.length > 15
        ? `<span class="text-dim" style="font-size:0.75rem;vertical-align:middle"> +${errors.length - 15} more</span>`
        : '';
      document.getElementById('errorServersList').innerHTML = badges + extra;
    } else {
      document.getElementById('errorServersSection').style.display = 'none';
    }

    // Phase 5: Config
    setProgress('Generating config...', 98);
    const config = generateConfig(ranked, configId);
    renderConfig(config, configId);

    setProgress('Done!', 100);
  } catch (e) {
    showError('Benchmark failed: ' + e.message);
    console.error(e);
  } finally {
    btn.disabled = false;
    btn.textContent = 'Run Benchmark';
    document.getElementById('progressFill').classList.remove('running');
    setTimeout(() => { progressSection.style.display = 'none'; }, 1000);
  }
}

// Allow Enter key on config ID input
document.getElementById('configId').addEventListener('keydown', e => {
  if (e.key === 'Enter') runBenchmark();
});

// Card spotlight: track cursor position for radial gradient on config blocks
document.addEventListener('mousemove', e => {
  const card = e.target.closest('.config-block');
  if (!card) return;
  const r = card.getBoundingClientRect();
  card.style.setProperty('--mouse-x', (e.clientX - r.left) + 'px');
  card.style.setProperty('--mouse-y', (e.clientY - r.top) + 'px');
});
</script>
</body>
</html>
